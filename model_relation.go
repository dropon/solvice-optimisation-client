/*
VRP API

             Welcome to the Solvice API! You can use our API to access Solvice API endpoints,             which can get information on your solved jobs,             their statuses and of course post new solve jobs.         

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the Relation type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &Relation{}

// Relation Relation between two jobs.
type Relation struct {
	// Type of relationship constraint between jobs. SAME_TRIP: jobs must be on the same vehicle/day. SEQUENCE: jobs must be done in order with optional time intervals. DIRECT_SEQUENCE: jobs must be consecutive with no other jobs between them. NEIGHBOR: jobs must be geographically close. SAME_TIME: jobs must be done simultaneously. PICKUP_AND_DELIVERY: first job is pickup, second is delivery. SAME_RESOURCE: jobs must use the same resource. SAME_DAY: jobs must be on the same day. GROUP_SEQUENCE: jobs with matching tags must be in sequence.
	Type RelationType `json:"type"`
	// List of job names involved in this relation. For sequence-based relations, the order matters - jobs will be executed in the order specified. For other relations, order may be irrelevant. All job names must exist in the request's jobs list.
	Jobs []string `json:"jobs"`
	// Optional resource constraint for this relation. When specified, all jobs in the relation must be assigned to this specific resource. This creates a hard constraint that can help enforce resource-specific workflows or capabilities.
	Resource NullableString `json:"resource,omitempty"`
	// Minimum time interval in seconds that must pass between consecutive jobs in sequence relations. This ensures adequate time for travel, setup, or processing between related jobs. Only applies to SEQUENCE, DIRECT_SEQUENCE, and SAME_TIME relations.
	MinTimeInterval NullableInt32 `json:"minTimeInterval,omitempty"`
	// Maximum time interval in seconds allowed between consecutive jobs in sequence relations. This prevents excessive delays between related jobs and ensures timely completion of job sequences. Only applies to SEQUENCE, DIRECT_SEQUENCE, and SAME_TIME relations.
	MaxTimeInterval NullableInt32 `json:"maxTimeInterval,omitempty"`
	// Allows the solver to include only some jobs from this relation in the final solution when the full relation cannot be satisfied due to constraints. When false, either all jobs in the relation are assigned or none are, maintaining the relation's integrity.
	PartialPlanning *bool `json:"partialPlanning,omitempty"`
	// Maximum waiting time in seconds between jobs in a SAME_TIME relation. This defines how much time synchronization tolerance is allowed - jobs can start within this time window of each other. Defaults to 1200 seconds (20 minutes) if not specified.
	MaxWaitingTime NullableInt32 `json:"maxWaitingTime,omitempty"`
	// Reference point for measuring time intervals between jobs in sequence relations. FROM_ARRIVAL (default) measures from when the first job's service begins to when the second job's service begins. FROM_DEPARTURE measures from when the first job's service ends to when the second job's service begins.
	TimeInterval TimeInterval `json:"timeInterval"`
	// List of tag names used to define job groups in GROUP_SEQUENCE relations. Jobs with matching tags form groups that must be executed in sequence. This allows for complex sequencing rules based on job characteristics rather than explicit job names.
	Tags []string `json:"tags,omitempty"`
	// When true, enforces resource compatibility checking for SAME_TIME relations. Only compatible resources can work together on linked jobs.
	EnforceCompatibility *bool `json:"enforceCompatibility,omitempty"`
	// When true (default), the minimum time interval constraint is enforced as a hard constraint. When false, it becomes a soft constraint that can be violated with penalty. Useful for SEQUENCE and SAME_TIME relations where timing flexibility is acceptable.
	HardMinWait *bool `json:"hardMinWait,omitempty"`
	// Weight modifier for this relation. This can be used to modify the weight of a relation to make it more or less important than other relations.
	Weight NullableInt32 `json:"weight,omitempty"`
}

type _Relation Relation

// NewRelation instantiates a new Relation object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewRelation(type_ RelationType, jobs []string, timeInterval TimeInterval) *Relation {
	this := Relation{}
	this.Type = type_
	this.Jobs = jobs
	this.TimeInterval = timeInterval
	return &this
}

// NewRelationWithDefaults instantiates a new Relation object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewRelationWithDefaults() *Relation {
	this := Relation{}
	return &this
}

// GetType returns the Type field value
func (o *Relation) GetType() RelationType {
	if o == nil {
		var ret RelationType
		return ret
	}

	return o.Type
}

// GetTypeOk returns a tuple with the Type field value
// and a boolean to check if the value has been set.
func (o *Relation) GetTypeOk() (*RelationType, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Type, true
}

// SetType sets field value
func (o *Relation) SetType(v RelationType) {
	o.Type = v
}

// GetJobs returns the Jobs field value
func (o *Relation) GetJobs() []string {
	if o == nil {
		var ret []string
		return ret
	}

	return o.Jobs
}

// GetJobsOk returns a tuple with the Jobs field value
// and a boolean to check if the value has been set.
func (o *Relation) GetJobsOk() ([]string, bool) {
	if o == nil {
		return nil, false
	}
	return o.Jobs, true
}

// SetJobs sets field value
func (o *Relation) SetJobs(v []string) {
	o.Jobs = v
}

// GetResource returns the Resource field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *Relation) GetResource() string {
	if o == nil || IsNil(o.Resource.Get()) {
		var ret string
		return ret
	}
	return *o.Resource.Get()
}

// GetResourceOk returns a tuple with the Resource field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *Relation) GetResourceOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.Resource.Get(), o.Resource.IsSet()
}

// HasResource returns a boolean if a field has been set.
func (o *Relation) HasResource() bool {
	if o != nil && o.Resource.IsSet() {
		return true
	}

	return false
}

// SetResource gets a reference to the given NullableString and assigns it to the Resource field.
func (o *Relation) SetResource(v string) {
	o.Resource.Set(&v)
}
// SetResourceNil sets the value for Resource to be an explicit nil
func (o *Relation) SetResourceNil() {
	o.Resource.Set(nil)
}

// UnsetResource ensures that no value is present for Resource, not even an explicit nil
func (o *Relation) UnsetResource() {
	o.Resource.Unset()
}

// GetMinTimeInterval returns the MinTimeInterval field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *Relation) GetMinTimeInterval() int32 {
	if o == nil || IsNil(o.MinTimeInterval.Get()) {
		var ret int32
		return ret
	}
	return *o.MinTimeInterval.Get()
}

// GetMinTimeIntervalOk returns a tuple with the MinTimeInterval field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *Relation) GetMinTimeIntervalOk() (*int32, bool) {
	if o == nil {
		return nil, false
	}
	return o.MinTimeInterval.Get(), o.MinTimeInterval.IsSet()
}

// HasMinTimeInterval returns a boolean if a field has been set.
func (o *Relation) HasMinTimeInterval() bool {
	if o != nil && o.MinTimeInterval.IsSet() {
		return true
	}

	return false
}

// SetMinTimeInterval gets a reference to the given NullableInt32 and assigns it to the MinTimeInterval field.
func (o *Relation) SetMinTimeInterval(v int32) {
	o.MinTimeInterval.Set(&v)
}
// SetMinTimeIntervalNil sets the value for MinTimeInterval to be an explicit nil
func (o *Relation) SetMinTimeIntervalNil() {
	o.MinTimeInterval.Set(nil)
}

// UnsetMinTimeInterval ensures that no value is present for MinTimeInterval, not even an explicit nil
func (o *Relation) UnsetMinTimeInterval() {
	o.MinTimeInterval.Unset()
}

// GetMaxTimeInterval returns the MaxTimeInterval field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *Relation) GetMaxTimeInterval() int32 {
	if o == nil || IsNil(o.MaxTimeInterval.Get()) {
		var ret int32
		return ret
	}
	return *o.MaxTimeInterval.Get()
}

// GetMaxTimeIntervalOk returns a tuple with the MaxTimeInterval field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *Relation) GetMaxTimeIntervalOk() (*int32, bool) {
	if o == nil {
		return nil, false
	}
	return o.MaxTimeInterval.Get(), o.MaxTimeInterval.IsSet()
}

// HasMaxTimeInterval returns a boolean if a field has been set.
func (o *Relation) HasMaxTimeInterval() bool {
	if o != nil && o.MaxTimeInterval.IsSet() {
		return true
	}

	return false
}

// SetMaxTimeInterval gets a reference to the given NullableInt32 and assigns it to the MaxTimeInterval field.
func (o *Relation) SetMaxTimeInterval(v int32) {
	o.MaxTimeInterval.Set(&v)
}
// SetMaxTimeIntervalNil sets the value for MaxTimeInterval to be an explicit nil
func (o *Relation) SetMaxTimeIntervalNil() {
	o.MaxTimeInterval.Set(nil)
}

// UnsetMaxTimeInterval ensures that no value is present for MaxTimeInterval, not even an explicit nil
func (o *Relation) UnsetMaxTimeInterval() {
	o.MaxTimeInterval.Unset()
}

// GetPartialPlanning returns the PartialPlanning field value if set, zero value otherwise.
func (o *Relation) GetPartialPlanning() bool {
	if o == nil || IsNil(o.PartialPlanning) {
		var ret bool
		return ret
	}
	return *o.PartialPlanning
}

// GetPartialPlanningOk returns a tuple with the PartialPlanning field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Relation) GetPartialPlanningOk() (*bool, bool) {
	if o == nil || IsNil(o.PartialPlanning) {
		return nil, false
	}
	return o.PartialPlanning, true
}

// HasPartialPlanning returns a boolean if a field has been set.
func (o *Relation) HasPartialPlanning() bool {
	if o != nil && !IsNil(o.PartialPlanning) {
		return true
	}

	return false
}

// SetPartialPlanning gets a reference to the given bool and assigns it to the PartialPlanning field.
func (o *Relation) SetPartialPlanning(v bool) {
	o.PartialPlanning = &v
}

// GetMaxWaitingTime returns the MaxWaitingTime field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *Relation) GetMaxWaitingTime() int32 {
	if o == nil || IsNil(o.MaxWaitingTime.Get()) {
		var ret int32
		return ret
	}
	return *o.MaxWaitingTime.Get()
}

// GetMaxWaitingTimeOk returns a tuple with the MaxWaitingTime field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *Relation) GetMaxWaitingTimeOk() (*int32, bool) {
	if o == nil {
		return nil, false
	}
	return o.MaxWaitingTime.Get(), o.MaxWaitingTime.IsSet()
}

// HasMaxWaitingTime returns a boolean if a field has been set.
func (o *Relation) HasMaxWaitingTime() bool {
	if o != nil && o.MaxWaitingTime.IsSet() {
		return true
	}

	return false
}

// SetMaxWaitingTime gets a reference to the given NullableInt32 and assigns it to the MaxWaitingTime field.
func (o *Relation) SetMaxWaitingTime(v int32) {
	o.MaxWaitingTime.Set(&v)
}
// SetMaxWaitingTimeNil sets the value for MaxWaitingTime to be an explicit nil
func (o *Relation) SetMaxWaitingTimeNil() {
	o.MaxWaitingTime.Set(nil)
}

// UnsetMaxWaitingTime ensures that no value is present for MaxWaitingTime, not even an explicit nil
func (o *Relation) UnsetMaxWaitingTime() {
	o.MaxWaitingTime.Unset()
}

// GetTimeInterval returns the TimeInterval field value
func (o *Relation) GetTimeInterval() TimeInterval {
	if o == nil {
		var ret TimeInterval
		return ret
	}

	return o.TimeInterval
}

// GetTimeIntervalOk returns a tuple with the TimeInterval field value
// and a boolean to check if the value has been set.
func (o *Relation) GetTimeIntervalOk() (*TimeInterval, bool) {
	if o == nil {
		return nil, false
	}
	return &o.TimeInterval, true
}

// SetTimeInterval sets field value
func (o *Relation) SetTimeInterval(v TimeInterval) {
	o.TimeInterval = v
}

// GetTags returns the Tags field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *Relation) GetTags() []string {
	if o == nil {
		var ret []string
		return ret
	}
	return o.Tags
}

// GetTagsOk returns a tuple with the Tags field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *Relation) GetTagsOk() ([]string, bool) {
	if o == nil || IsNil(o.Tags) {
		return nil, false
	}
	return o.Tags, true
}

// HasTags returns a boolean if a field has been set.
func (o *Relation) HasTags() bool {
	if o != nil && !IsNil(o.Tags) {
		return true
	}

	return false
}

// SetTags gets a reference to the given []string and assigns it to the Tags field.
func (o *Relation) SetTags(v []string) {
	o.Tags = v
}

// GetEnforceCompatibility returns the EnforceCompatibility field value if set, zero value otherwise.
func (o *Relation) GetEnforceCompatibility() bool {
	if o == nil || IsNil(o.EnforceCompatibility) {
		var ret bool
		return ret
	}
	return *o.EnforceCompatibility
}

// GetEnforceCompatibilityOk returns a tuple with the EnforceCompatibility field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Relation) GetEnforceCompatibilityOk() (*bool, bool) {
	if o == nil || IsNil(o.EnforceCompatibility) {
		return nil, false
	}
	return o.EnforceCompatibility, true
}

// HasEnforceCompatibility returns a boolean if a field has been set.
func (o *Relation) HasEnforceCompatibility() bool {
	if o != nil && !IsNil(o.EnforceCompatibility) {
		return true
	}

	return false
}

// SetEnforceCompatibility gets a reference to the given bool and assigns it to the EnforceCompatibility field.
func (o *Relation) SetEnforceCompatibility(v bool) {
	o.EnforceCompatibility = &v
}

// GetHardMinWait returns the HardMinWait field value if set, zero value otherwise.
func (o *Relation) GetHardMinWait() bool {
	if o == nil || IsNil(o.HardMinWait) {
		var ret bool
		return ret
	}
	return *o.HardMinWait
}

// GetHardMinWaitOk returns a tuple with the HardMinWait field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Relation) GetHardMinWaitOk() (*bool, bool) {
	if o == nil || IsNil(o.HardMinWait) {
		return nil, false
	}
	return o.HardMinWait, true
}

// HasHardMinWait returns a boolean if a field has been set.
func (o *Relation) HasHardMinWait() bool {
	if o != nil && !IsNil(o.HardMinWait) {
		return true
	}

	return false
}

// SetHardMinWait gets a reference to the given bool and assigns it to the HardMinWait field.
func (o *Relation) SetHardMinWait(v bool) {
	o.HardMinWait = &v
}

// GetWeight returns the Weight field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *Relation) GetWeight() int32 {
	if o == nil || IsNil(o.Weight.Get()) {
		var ret int32
		return ret
	}
	return *o.Weight.Get()
}

// GetWeightOk returns a tuple with the Weight field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *Relation) GetWeightOk() (*int32, bool) {
	if o == nil {
		return nil, false
	}
	return o.Weight.Get(), o.Weight.IsSet()
}

// HasWeight returns a boolean if a field has been set.
func (o *Relation) HasWeight() bool {
	if o != nil && o.Weight.IsSet() {
		return true
	}

	return false
}

// SetWeight gets a reference to the given NullableInt32 and assigns it to the Weight field.
func (o *Relation) SetWeight(v int32) {
	o.Weight.Set(&v)
}
// SetWeightNil sets the value for Weight to be an explicit nil
func (o *Relation) SetWeightNil() {
	o.Weight.Set(nil)
}

// UnsetWeight ensures that no value is present for Weight, not even an explicit nil
func (o *Relation) UnsetWeight() {
	o.Weight.Unset()
}

func (o Relation) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o Relation) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["type"] = o.Type
	toSerialize["jobs"] = o.Jobs
	if o.Resource.IsSet() {
		toSerialize["resource"] = o.Resource.Get()
	}
	if o.MinTimeInterval.IsSet() {
		toSerialize["minTimeInterval"] = o.MinTimeInterval.Get()
	}
	if o.MaxTimeInterval.IsSet() {
		toSerialize["maxTimeInterval"] = o.MaxTimeInterval.Get()
	}
	if !IsNil(o.PartialPlanning) {
		toSerialize["partialPlanning"] = o.PartialPlanning
	}
	if o.MaxWaitingTime.IsSet() {
		toSerialize["maxWaitingTime"] = o.MaxWaitingTime.Get()
	}
	toSerialize["timeInterval"] = o.TimeInterval
	if o.Tags != nil {
		toSerialize["tags"] = o.Tags
	}
	if !IsNil(o.EnforceCompatibility) {
		toSerialize["enforceCompatibility"] = o.EnforceCompatibility
	}
	if !IsNil(o.HardMinWait) {
		toSerialize["hardMinWait"] = o.HardMinWait
	}
	if o.Weight.IsSet() {
		toSerialize["weight"] = o.Weight.Get()
	}
	return toSerialize, nil
}

func (o *Relation) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"type",
		"jobs",
		"timeInterval",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varRelation := _Relation{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varRelation)

	if err != nil {
		return err
	}

	*o = Relation(varRelation)

	return err
}

type NullableRelation struct {
	value *Relation
	isSet bool
}

func (v NullableRelation) Get() *Relation {
	return v.value
}

func (v *NullableRelation) Set(val *Relation) {
	v.value = val
	v.isSet = true
}

func (v NullableRelation) IsSet() bool {
	return v.isSet
}

func (v *NullableRelation) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableRelation(val *Relation) *NullableRelation {
	return &NullableRelation{value: val, isSet: true}
}

func (v NullableRelation) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableRelation) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


