/*
VRP API

             Welcome to the Solvice API! You can use our API to access Solvice API endpoints,             which can get information on your solved jobs,             their statuses and of course post new solve jobs.         

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// Status the model 'Status'
type Status string

// List of Status
const (
	OK Status = "OK"
	CREATED Status = "CREATED"
	ACCEPTED Status = "ACCEPTED"
	NO_CONTENT Status = "NO_CONTENT"
	RESET_CONTENT Status = "RESET_CONTENT"
	PARTIAL_CONTENT Status = "PARTIAL_CONTENT"
	MULTIPLE_CHOICES Status = "MULTIPLE_CHOICES"
	MOVED_PERMANENTLY Status = "MOVED_PERMANENTLY"
	FOUND Status = "FOUND"
	SEE_OTHER Status = "SEE_OTHER"
	NOT_MODIFIED Status = "NOT_MODIFIED"
	USE_PROXY Status = "USE_PROXY"
	TEMPORARY_REDIRECT Status = "TEMPORARY_REDIRECT"
	PERMANENT_REDIRECT Status = "PERMANENT_REDIRECT"
	BAD_REQUEST Status = "BAD_REQUEST"
	UNAUTHORIZED Status = "UNAUTHORIZED"
	PAYMENT_REQUIRED Status = "PAYMENT_REQUIRED"
	FORBIDDEN Status = "FORBIDDEN"
	NOT_FOUND Status = "NOT_FOUND"
	METHOD_NOT_ALLOWED Status = "METHOD_NOT_ALLOWED"
	NOT_ACCEPTABLE Status = "NOT_ACCEPTABLE"
	PROXY_AUTHENTICATION_REQUIRED Status = "PROXY_AUTHENTICATION_REQUIRED"
	REQUEST_TIMEOUT Status = "REQUEST_TIMEOUT"
	CONFLICT Status = "CONFLICT"
	GONE Status = "GONE"
	LENGTH_REQUIRED Status = "LENGTH_REQUIRED"
	PRECONDITION_FAILED Status = "PRECONDITION_FAILED"
	REQUEST_ENTITY_TOO_LARGE Status = "REQUEST_ENTITY_TOO_LARGE"
	REQUEST_URI_TOO_LONG Status = "REQUEST_URI_TOO_LONG"
	UNSUPPORTED_MEDIA_TYPE Status = "UNSUPPORTED_MEDIA_TYPE"
	REQUESTED_RANGE_NOT_SATISFIABLE Status = "REQUESTED_RANGE_NOT_SATISFIABLE"
	EXPECTATION_FAILED Status = "EXPECTATION_FAILED"
	PRECONDITION_REQUIRED Status = "PRECONDITION_REQUIRED"
	TOO_MANY_REQUESTS Status = "TOO_MANY_REQUESTS"
	REQUEST_HEADER_FIELDS_TOO_LARGE Status = "REQUEST_HEADER_FIELDS_TOO_LARGE"
	UNAVAILABLE_FOR_LEGAL_REASONS Status = "UNAVAILABLE_FOR_LEGAL_REASONS"
	INTERNAL_SERVER_ERROR Status = "INTERNAL_SERVER_ERROR"
	NOT_IMPLEMENTED Status = "NOT_IMPLEMENTED"
	BAD_GATEWAY Status = "BAD_GATEWAY"
	SERVICE_UNAVAILABLE Status = "SERVICE_UNAVAILABLE"
	GATEWAY_TIMEOUT Status = "GATEWAY_TIMEOUT"
	HTTP_VERSION_NOT_SUPPORTED Status = "HTTP_VERSION_NOT_SUPPORTED"
	NETWORK_AUTHENTICATION_REQUIRED Status = "NETWORK_AUTHENTICATION_REQUIRED"
)

// All allowed values of Status enum
var AllowedStatusEnumValues = []Status{
	"OK",
	"CREATED",
	"ACCEPTED",
	"NO_CONTENT",
	"RESET_CONTENT",
	"PARTIAL_CONTENT",
	"MULTIPLE_CHOICES",
	"MOVED_PERMANENTLY",
	"FOUND",
	"SEE_OTHER",
	"NOT_MODIFIED",
	"USE_PROXY",
	"TEMPORARY_REDIRECT",
	"PERMANENT_REDIRECT",
	"BAD_REQUEST",
	"UNAUTHORIZED",
	"PAYMENT_REQUIRED",
	"FORBIDDEN",
	"NOT_FOUND",
	"METHOD_NOT_ALLOWED",
	"NOT_ACCEPTABLE",
	"PROXY_AUTHENTICATION_REQUIRED",
	"REQUEST_TIMEOUT",
	"CONFLICT",
	"GONE",
	"LENGTH_REQUIRED",
	"PRECONDITION_FAILED",
	"REQUEST_ENTITY_TOO_LARGE",
	"REQUEST_URI_TOO_LONG",
	"UNSUPPORTED_MEDIA_TYPE",
	"REQUESTED_RANGE_NOT_SATISFIABLE",
	"EXPECTATION_FAILED",
	"PRECONDITION_REQUIRED",
	"TOO_MANY_REQUESTS",
	"REQUEST_HEADER_FIELDS_TOO_LARGE",
	"UNAVAILABLE_FOR_LEGAL_REASONS",
	"INTERNAL_SERVER_ERROR",
	"NOT_IMPLEMENTED",
	"BAD_GATEWAY",
	"SERVICE_UNAVAILABLE",
	"GATEWAY_TIMEOUT",
	"HTTP_VERSION_NOT_SUPPORTED",
	"NETWORK_AUTHENTICATION_REQUIRED",
}

func (v *Status) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := Status(value)
	for _, existing := range AllowedStatusEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid Status", value)
}

// NewStatusFromValue returns a pointer to a valid Status
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewStatusFromValue(v string) (*Status, error) {
	ev := Status(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for Status: valid values are %v", v, AllowedStatusEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v Status) IsValid() bool {
	for _, existing := range AllowedStatusEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to Status value
func (v Status) Ptr() *Status {
	return &v
}

type NullableStatus struct {
	value *Status
	isSet bool
}

func (v NullableStatus) Get() *Status {
	return v.value
}

func (v *NullableStatus) Set(val *Status) {
	v.value = val
	v.isSet = true
}

func (v NullableStatus) IsSet() bool {
	return v.isSet
}

func (v *NullableStatus) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableStatus(val *Status) *NullableStatus {
	return &NullableStatus{value: val, isSet: true}
}

func (v NullableStatus) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableStatus) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

