/*
VRP API

             Welcome to the Solvice API! You can use our API to access Solvice API endpoints,             which can get information on your solved jobs,             their statuses and of course post new solve jobs.         

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the RoutingExplanation type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &RoutingExplanation{}

// RoutingExplanation Explains the conflicts of a certain routing solution and the unresolved constraints.
type RoutingExplanation struct {
	Score NullableRoutingExplanationScore `json:"score"`
	// Conflicts in the solution
	Conflicts []RoutingConflict `json:"conflicts,omitempty"`
	// Unresolved constraints in the solution
	Unresolved []Unresolved `json:"unresolved,omitempty"`
	// When `options.explanation.enabled` is set to `true`, this field will contain the alternatives for the solution.The key is the job name and the value is the list of assignments. Each assignment contains the resource, the date, and the score. In this way, you can check the impact of the alternative on the score.
	Alternatives map[string]map[string]interface{} `json:"alternatives,omitempty"`
}

type _RoutingExplanation RoutingExplanation

// NewRoutingExplanation instantiates a new RoutingExplanation object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewRoutingExplanation(score NullableRoutingExplanationScore) *RoutingExplanation {
	this := RoutingExplanation{}
	this.Score = score
	return &this
}

// NewRoutingExplanationWithDefaults instantiates a new RoutingExplanation object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewRoutingExplanationWithDefaults() *RoutingExplanation {
	this := RoutingExplanation{}
	return &this
}

// GetScore returns the Score field value
// If the value is explicit nil, the zero value for RoutingExplanationScore will be returned
func (o *RoutingExplanation) GetScore() RoutingExplanationScore {
	if o == nil || o.Score.Get() == nil {
		var ret RoutingExplanationScore
		return ret
	}

	return *o.Score.Get()
}

// GetScoreOk returns a tuple with the Score field value
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *RoutingExplanation) GetScoreOk() (*RoutingExplanationScore, bool) {
	if o == nil {
		return nil, false
	}
	return o.Score.Get(), o.Score.IsSet()
}

// SetScore sets field value
func (o *RoutingExplanation) SetScore(v RoutingExplanationScore) {
	o.Score.Set(&v)
}

// GetConflicts returns the Conflicts field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *RoutingExplanation) GetConflicts() []RoutingConflict {
	if o == nil {
		var ret []RoutingConflict
		return ret
	}
	return o.Conflicts
}

// GetConflictsOk returns a tuple with the Conflicts field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *RoutingExplanation) GetConflictsOk() (*[]RoutingConflict, bool) {
	if o == nil || IsNil(o.Conflicts) {
		return nil, false
	}
	return &o.Conflicts, true
}

// HasConflicts returns a boolean if a field has been set.
func (o *RoutingExplanation) HasConflicts() bool {
	if o != nil && !IsNil(o.Conflicts) {
		return true
	}

	return false
}

// SetConflicts gets a reference to the given []RoutingConflict and assigns it to the Conflicts field.
func (o *RoutingExplanation) SetConflicts(v []RoutingConflict) {
	o.Conflicts = v
}

// GetUnresolved returns the Unresolved field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *RoutingExplanation) GetUnresolved() []Unresolved {
	if o == nil {
		var ret []Unresolved
		return ret
	}
	return o.Unresolved
}

// GetUnresolvedOk returns a tuple with the Unresolved field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *RoutingExplanation) GetUnresolvedOk() (*[]Unresolved, bool) {
	if o == nil || IsNil(o.Unresolved) {
		return nil, false
	}
	return &o.Unresolved, true
}

// HasUnresolved returns a boolean if a field has been set.
func (o *RoutingExplanation) HasUnresolved() bool {
	if o != nil && !IsNil(o.Unresolved) {
		return true
	}

	return false
}

// SetUnresolved gets a reference to the given []Unresolved and assigns it to the Unresolved field.
func (o *RoutingExplanation) SetUnresolved(v []Unresolved) {
	o.Unresolved = v
}

// GetAlternatives returns the Alternatives field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *RoutingExplanation) GetAlternatives() map[string]map[string]interface{} {
	if o == nil {
		var ret map[string]map[string]interface{}
		return ret
	}
	return o.Alternatives
}

// GetAlternativesOk returns a tuple with the Alternatives field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *RoutingExplanation) GetAlternativesOk() (map[string]map[string]interface{}, bool) {
	if o == nil || IsNil(o.Alternatives) {
		return map[string]map[string]interface{}{}, false
	}
	return o.Alternatives, true
}

// HasAlternatives returns a boolean if a field has been set.
func (o *RoutingExplanation) HasAlternatives() bool {
	if o != nil && !IsNil(o.Alternatives) {
		return true
	}

	return false
}

// SetAlternatives gets a reference to the given map[string]map[string]interface{} and assigns it to the Alternatives field.
func (o *RoutingExplanation) SetAlternatives(v map[string]map[string]interface{}) {
	o.Alternatives = v
}

func (o RoutingExplanation) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o RoutingExplanation) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["score"] = o.Score.Get()
	if o.Conflicts != nil {
		toSerialize["conflicts"] = o.Conflicts
	}
	if o.Unresolved != nil {
		toSerialize["unresolved"] = o.Unresolved
	}
	if o.Alternatives != nil {
		toSerialize["alternatives"] = o.Alternatives
	}
	return toSerialize, nil
}

func (o *RoutingExplanation) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"score",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varRoutingExplanation := _RoutingExplanation{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varRoutingExplanation)

	if err != nil {
		return err
	}

	*o = RoutingExplanation(varRoutingExplanation)

	return err
}

type NullableRoutingExplanation struct {
	value *RoutingExplanation
	isSet bool
}

func (v NullableRoutingExplanation) Get() *RoutingExplanation {
	return v.value
}

func (v *NullableRoutingExplanation) Set(val *RoutingExplanation) {
	v.value = val
	v.isSet = true
}

func (v NullableRoutingExplanation) IsSet() bool {
	return v.isSet
}

func (v *NullableRoutingExplanation) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableRoutingExplanation(val *RoutingExplanation) *NullableRoutingExplanation {
	return &NullableRoutingExplanation{value: val, isSet: true}
}

func (v NullableRoutingExplanation) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableRoutingExplanation) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


