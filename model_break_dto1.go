/*
VRP API

             Welcome to the Solvice API! You can use our API to access Solvice API endpoints,             which can get information on your solved jobs,             their statuses and of course post new solve jobs.         

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the BreakDto1 type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &BreakDto1{}

// BreakDto1 struct for BreakDto1
type BreakDto1 struct {
	Type BreakType `json:"type"`
}

type _BreakDto1 BreakDto1

// NewBreakDto1 instantiates a new BreakDto1 object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewBreakDto1(type_ BreakType) *BreakDto1 {
	this := BreakDto1{}
	this.Type = type_
	return &this
}

// NewBreakDto1WithDefaults instantiates a new BreakDto1 object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewBreakDto1WithDefaults() *BreakDto1 {
	this := BreakDto1{}
	return &this
}

// GetType returns the Type field value
func (o *BreakDto1) GetType() BreakType {
	if o == nil {
		var ret BreakType
		return ret
	}

	return o.Type
}

// GetTypeOk returns a tuple with the Type field value
// and a boolean to check if the value has been set.
func (o *BreakDto1) GetTypeOk() (*BreakType, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Type, true
}

// SetType sets field value
func (o *BreakDto1) SetType(v BreakType) {
	o.Type = v
}

func (o BreakDto1) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o BreakDto1) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["type"] = o.Type
	return toSerialize, nil
}

func (o *BreakDto1) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"type",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varBreakDto1 := _BreakDto1{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varBreakDto1)

	if err != nil {
		return err
	}

	*o = BreakDto1(varBreakDto1)

	return err
}

type NullableBreakDto1 struct {
	value *BreakDto1
	isSet bool
}

func (v NullableBreakDto1) Get() *BreakDto1 {
	return v.value
}

func (v *NullableBreakDto1) Set(val *BreakDto1) {
	v.value = val
	v.isSet = true
}

func (v NullableBreakDto1) IsSet() bool {
	return v.isSet
}

func (v *NullableBreakDto1) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableBreakDto1(val *BreakDto1) *NullableBreakDto1 {
	return &NullableBreakDto1{value: val, isSet: true}
}

func (v NullableBreakDto1) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableBreakDto1) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


